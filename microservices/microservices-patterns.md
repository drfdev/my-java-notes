### Паттерны Микросервисов

###### Паттерны декомпозиции на микросервисы

* Разбиение по бизнес-возможностям (Decompose By Business Capability)
  Разбиение на микросервисы путем определения бизнес возможностей и создание по микросервису на каждую  
  Пример:
  - управление заказом
  - управление доставкой
  - управление оповещением
  - управление предзаказами
  - управление платежами
  - управление клиентами
  - управление каталогом
  - управление корзиной
* Разбиение по поддоменам (Decompose By Subdomain)
  Предыдущий вариант создает "божественный классы" (God Classes) - сущности общие для разных сервисов.
  Чтобы избежать этого, можно использовать предметно-ориентированное проектирование (Domain-Driven Design, DDD).  
  Пример:
  - Заказы (Orders Subdomain)
  - Каталог (Catalog Subdomain)
  - Клиенты (Client Subdomain)
  - Оплата (Payments Subdomain)
  - Корзина (Cart Subdomain)


###### Паттерны рефакторинга для перехода на микросервисы

* **Душитель (Strangler)**  
  Хорошо подходит для новых приложений. Подходит для раскладывания монолита на микросервисы.
  Шаблон нужен для постепенного переноса существующего монолита в микросервисы.
  Настраивается маршрутизация запросов между устаревшим монолитом и микросервисами.
  Когда очередная функциональность переносится из монолита в микросервисы, фасад перехватывает клиентский запрос
  и направляет его к микросервисам. Новые функции при этом реализуются исключительно в микросервисах, минуя монолит.
  После переноса всех функций монолитное приложение полностью выводится из эксплуатации.
  Рекомендуется для небольших монолитов
* **Уровень защиты от повреждений (Anti-Corruption Layer)**  
  Некоторые легаси системы переводить в микросервисы долго или вообще невозможно.
  Шаблон предназначен для изолирования различных подсистем путем размещения между ними дополнительного уровня,
  который может быть реализован как компонент приложения или независимая служба.
  Этот уровень связывает две подсистемы, позволяя им оставаться максимально независимыми друг от друга.
  Он содержит всю логику, необходимую для передачи данных в обе стороны:
  при взаимодействии с каждой из подсистем используется именно ее модель данных.


###### Паттерны управления данными в микросервисной архитектуре

* **База данных на сервис (Database Per Service)**  
  Каждому микросервису выделяется свое хранилище данных (или схема в одной базе данных).
  Что повышает автономность микросервисов и уменьшает связь между командами, разрабатывающими отдельные сервисы.
  Подходит для больших проектов (крупномасштабных проектов с большим числом микросервисов).
  Shared Database - антипаттерн, использование одного хранилища разными микросервисами. Не надо так делать.
* **API-композиция (API Composition)** 
  Этот шаблон является одним из возможных вариантов получения данных из нескольких сервисов
  после применения к ним паттерна Database Per Service. Он предлагает создать отдельное API,
  которое будет вызывать необходимые сервисы, владеющие данными, и выполнять соединение полученных
  от них результатов в памяти.
* **Разделение команд и запросов (Command Query Responsibility Segregation, CQRS)**  
  Альтернатива предыдущему паттерну.
  Этот паттерн предлагает отделить изменение данных (Command) от чтения данных (Query).
  Шаблон CQRS имеет две формы: простую и расширенную.  
  - Простая
    Для чтения и записи используются отдельные модели ORM (Object-Relational Mapping), но общее хранилище данных.  
  - Расширенная
    Используются разные хранилища данных, оптимизированные для записи и чтения данных.
    Данные копируются из хранилища для записи в хранилище для чтения асинхронно.
    В результате хранилище для чтения отстает от хранилища для записи, но в конечном итоге является согласованным.
  
  Паттерн CQRS обеспечивает высокую доступность данных, независимое масштабирование систем чтения/записи
  и более быстрое чтение данных в микросервисах, управляемых событиями.
  Однако его использование увеличивает сложность системы и приводит к слабой согласованности данных.
* **Поиск событий (Event Sourcing)**  
  В традиционных базах данных объект с текущим состоянием сохраняется напрямую.
  При использовании шаблона Event Sourcing вместо объектов сохраняются события,
  изменяющие их состояния. Итоговое состояние объекта можно получить путем повторной обработки серии событий,
  пришедших за определенное время.
  Различные службы могут воспроизводить события из хранилища событий,
  чтобы вычислить соответствующее состояние своих хранилищ данных.
  Для реализации хранилища событий обычно применяется шаблон CQRS.
* **Сага (Saga)**  
  Смотри: pattern-saga.md
  Этот паттерн предназначен для управления распределенными транзакциями в микросервисной архитектуре,
  где применение традиционного протокола двухфазной фиксации транзакций (Two-phase commit protocol, 2PC)
  становится трудноосуществимым.
  При использовании паттерна каждая локальная транзакция обновляет данные в хранилище в рамках одного микросервиса
  и публикует событие или сообщение, которые, в свою очередь, запускают следующую локальную транзакцию и так далее. 
  Если локальная транзакция завершается с ошибкой, выполняется серия компенсирующих транзакций,
  которые отменяют изменения предыдущих транзакций.
  Для координации транзакций существует два основных способа:
  - Хореография
    Децентрализованная координация, при которой каждый микросервис прослушивает события/сообщения другого микросервиса
    и решает, следует предпринять действие или нет.
    см: pattern-choreography.md
  - Оркестровка
    Централизованная координация, при которой отдельный компонент (оркестратор) сообщает микросервисам,
    какое действие необходимо выполнить далее.
    см: pattern-orchestration.md
  
  Использование шаблона обеспечивает согласованность транзакций в слабосвязанных распределенных системах,
  однако увеличивает сложность отладки.


###### Паттерны коммуникации микросервисов

* **API-шлюз (API Gateway)**  
  Паттерн основан на применении шлюза, который находится между клиентским приложением и микросервисами,
  обеспечивая единую точку входа для клиента.
  В зависимости от конкретной цели использования паттерна иногда выделяют следующие его разновидности:
  - Gateway Routing  
    Шлюз используется как обратный Proxy, перенаправляющий запросы клиента на соответствующий сервис.
  - Gateway Aggregation  
    Шлюз используется для разветвления клиентского запроса на несколько микросервисов
    и возвращения агрегированных ответов клиенту.
  - Gateway Offloading  
    Шлюз решает сквозные задачи, которые являются общими для сервисов:
    аутентификация, авторизация, SSL, ведение журналов и так далее.

  Применение паттерна сокращает число вызовов, обеспечивает независимость клиента от протоколов,
  используемых в сервисах: REST, AMQP, gRPC и так далее,
  обеспечивает централизованное управление сквозной функциональностью.
  Однако шлюз может стать единой точкой отказа, требует тщательного мониторинга и
  при отсутствии масштабирования бывает узким местом системы.
* **Бэкенды для фронтендов (Backends for Frontends, BFF)**  
  Паттерн является вариантом реализации шаблона API Gateway.
  Он также обеспечивает дополнительный уровень между микросервисами и клиентами,
  но вместо одной точки входа вводит несколько шлюзов для каждого типа клиента: Web, Mobile, Desktop и так далее.
  С помощью паттерна можно добавить API, адаптированные к потребностям каждого клиента,
  избавившись от хранения большого количества ненужных настроек в одном месте.


###### Паттерны обнаружения сервисов в микросервисной архитектуре

* **Обнаружение сервисов на стороне клиента (Client-Side Service Discovery)**  
  Первый способ обнаружения сервисов — на стороне клиента.
  В этом случае сервисы и их клиенты напрямую взаимодействуют с реестром.
  Последовательность шагов следующая:
  - Экземпляр сервиса обращается к API реестра, чтобы зарегистрировать свое сетевое местоположение
  - Клиент самостоятельно обращается к реестру сервисов, чтобы получить список экземпляров сервисов
  - Клиент использует алгоритм балансировки нагрузки, чтобы выбрать конкретный экземпляр сервиса и отправить ему запрос.

  Ключевое преимущество обнаружения сервисов на стороне клиента — его независимость от используемой платформы развертывания.
  Например, если часть ваших сервисов развернута на K8s, а остальные работают в устаревшей среде,
  то обнаружение на уровне приложения будет лучшим вариантом, так как серверное решение на базе Kubernetes
  не будет совместимо со всеми сервисами.
* **Обнаружение сервисов на стороне сервера (Server-Side Service Discovery)**  
  Второй способ обнаружения сервисов — на стороне сервера. В этом случае за регистрацию,
  обнаружение сервисов и маршрутизацию запросов отвечает инфраструктура развертывания.
  Последовательность шагов следующая:
  - Регистратор, который обычно является частью платформы развертывания, прописывает все экземпляры сервисов в реестре сервисов
  - Вместо того чтобы обращаться к реестру напрямую, клиент делает запрос по DNS-имени сервиса
  - Маршрутизатор обращается к реестру сервисов для получения сетевого расположения экземпляров нужного сервиса
  - Маршрутизатор применяет балансировку нагрузки, чтобы выбрать конкретный экземпляр сервиса и отправить ему запрос

  Все современные платформы развертывания, включая Docker, Kubernetes и другие,
  как правило, имеют встроенный реестр и механизмы обнаружения сервисов.
  Основное преимущество паттерна состоит в том, что всеми аспектами обнаружения сервисов занимается сама платформа.
  Дополнительный код на стороне клиента или сервисов не требуется.
  Благодаря этому достигается независимость от используемых в приложении языков программирования и фреймворков.


###### Паттерны развертывания микросервисов

* **Экземпляр сервиса на хост (Service Instance Per Host)**  
  При переходе на микросервисную архитектуру рекомендуется проводить развертывание каждого
  экземпляра сервиса на собственном хосте (виртуальном или физическом).
  Паттерн Service Instance Per Host позволяет изолировать экземпляры сервисов друга от друга,
  избежать конфликтов версий и требований к ресурсам, максимально использовать ресурсы хоста,
  а также легче и быстрее проводить повторные развертывания.
  К недостаткам паттерна можно отнести потенциально менее эффективное использование ресурсов по сравнению
  с развертыванием нескольких экземпляров на хост.
* **Сине-зеленое развертывание (Blue-Green Deployment)**  
  Паттерн позволяет выполнить развертывание новых версий сервисов максимально незаметно для пользователей,
  сократив время простоя до минимума. Это достигается за счет запуска двух идентичных
  производственных сред — условно синего и зеленого цвета.
  Предположим, что синий — это существующий активный экземпляр, а зеленый — это новая версия приложения,
  развернутая параллельно с ним.
  В любой момент времени только одна из сред является активной,
  и именно она обслуживает весь производственный трафик.
  После успешного развертывания новой версии — с прохождением всех тестов и так далее — трафик переключается на нее.
  В случае ошибок всегда можно вернуться к предыдущей версии.


###### Паттерны повышения отказоустойчивости

* **Автоматический выключатель (Circuit Breaker)**  
  Микросервис будет запрашивать другой микросервис через Proxy-сервер.
  Он подсчитывает количество недавних сбоев и на основе него определяет,
  разрешать ли выполнение последующих вызовов или немедленно возвращать исключение.
  Proxy-сервер может находиться в трех состояниях:
  - Closed  
    Идет передача запросов между сервисами и подсчет количества сбоев.
    Если число сбоев за заданный интервал времени превышает пороговое значение,
    выключатель Proxy-сервера переводится в состояние Open.
  - Open  
    Запросы от исходного сервиса немедленно возвращаются с ошибкой.
    По истечении заданного тайм-аута выключатель переводится в состояние Half-Open.
  - Half-Open  
    Выключатель пропускает ограниченное количество запросов от исходного сервиса
    и подсчитывает число успешных запросов. Если необходимое количество достигнуто,
    выключатель переходит в состояние Closed, если нет — возвращается в статус Open.

  Использование шаблона повышает отказоустойчивость и предотвращает каскадные сбои,
  но требует тщательной настройки и мониторинга.
* **Переборка (Bulkhead)**  
  Свое название паттерн получил благодаря переборкам, используемым в судостроении:
  они защищают корабль от полного затопления в случае повреждения отдельных его частей.
  Так же и в архитектуре приложения: переборки изолируют элементы приложения в пулы,
  чтобы в случае сбоя одного из них остальные продолжали функционировать.
  Шаблон позволяет разделить ресурсы, чтобы гарантировать, что ресурсы,
  используемые для вызова одного сервиса, не влияют на ресурсы,
  используемые для вызова другого сервиса. Пример — использование отдельного пула соединений
  для каждого из нижестоящих сервисов.

  Еще один вариант использования шаблона — назначение каждому клиенту сервиса отдельного экземпляра сервиса.
  В таком случае, если один из клиентов сделает слишком много запросов, перегрузив свой экземпляр,
  другие клиенты смогут продолжить работу.

  Использование этого паттерна предотвращает каскадные сбои и изолирует критически важные ресурсы,
  но приводит к дополнительной сложности и менее эффективному использованию ресурсов.


###### Паттерны мониторинга микросервисов

* **Агрегация логов (Log Aggregation)**  
  Хорошей практикой при разработке микросервисов считается ведение логов каждым экземпляром сервиса.
  Логи могут содержать ошибки, предупреждения, информационные и отладочные сообщения.
  Но с увеличением числа сервисов анализ логов, разнесенных по различным хостам, становится затруднительным.
  Паттерн предлагает использовать централизованную службу ведения логов,
  которая будет собирать логи от каждого экземпляра сервиса.
  Это предоставит пользователям единую точку для поиска, анализа логов и настройки предупреждений,
  которые будут запускаться при появлении в них определенных сообщений.
* **Распределенная трассировка (Distributed Tracing)**  
  В микросервисной архитектуре для выполнения клиентских запросов может потребоваться работа
  нескольких взаимосвязанных микросервисов. Каждый сервис обрабатывает запрос путем выполнения одной 
  или нескольких операций, включая обращение к базе данных, публикацию сообщений и так далее.
  Паттерн предлагает назначать каждому внешнему запросу уникальный идентификатор (TraceId), 
  который будет передаваться всем сервисам, участвующим в обработке запроса,
  и фиксироваться в журналах. Это позволит разработчикам видеть, как обрабатывается отдельный запрос,
  путем поиска в агрегированных журналах его внешнего идентификатора.
* **Проверки здоровья (Health Check)**  
  Паттерн предлагает определить для каждого сервиса конечную точку,
  которую можно использовать для проверки работоспособности, например /health.
  Этот API должен проверять статус хоста, подключение к другим сервисам,
  инфраструктуре и любую иную бизнес-логику. Клиент — служба мониторинга,
  реестр служб или балансировщик нагрузки — будет периодически обращаться
  к конечной точке для проверки работоспособности экземпляра сервиса.


###### Прочие паттерны проектирования микросервисов

* **Посредник (Посол, Ambassador)**  
  Приложениям и сервисам часто требуются общие функции, относящиеся к мониторингу, 
  ведению журналов, настройкам безопасности, сетевым службам и так далее. 
  Однако в микросервисной архитектуре отдельные сервисы могут быть построены с помощью различных языков
  и технологий — следовательно, они могут иметь свои зависимости и требовать определенных языковых библиотек.
  Паттерн Ambassador предлагает помещать клиентские фреймворки и библиотеки для решения периферийных задач
  внутрь вспомогательного сервиса, выступающего в роли Proxy между клиентским приложением 
  или основным сервисом и прочими частями системы.
  Применение паттерна Ambassador позволяет:
  - Унифицировать обращение клиентских приложений к общим задачам
  - Решать периферийные задачи, не затрагивая основную функциональность
  - Добавлять новую функциональность в Legacy-приложения, которые тяжело поддаются рефакторингу

  Шаблон не рекомендуется использовать, когда время задержки критично.
  Также паттерн лучше не применять в случаях, когда можно обойтись стандартной клиентской библиотекой — например,
  если используется всего один язык или нет возможности выделить общие периферийные задачи.
* **Коляска (Прицеп, Sidecar)**  
  Паттерн предлагает помещать периферийные задачи, связанные с мониторингом, безопасностью,
  отказоустойчивостью и так далее, в отдельный компонент и развертывать его внутри собственного процесса
  или контейнера. Так обеспечивается однородный интерфейс для сервисов основного приложения,
  которые могут быть написаны на разных языках.
  Sidecar не обязательно является частью приложения, но связан с ним:
  для каждого экземпляра приложения рядом развертывается экземпляр Sidecar.
  Sidecar имеет тот же жизненный цикл, что и основное приложение.
  Преимуществами паттерна являются независимость вспомогательного компонента от платформы основного приложения,
  возможность их доступа к одним и тем же ресурсам, минимизация задержек из-за их близкого расположения
  и возможность независимого обновления.
  Шаблон не рекомендуется использовать для небольших приложений, а также в тех случаях,
  когда можно обойтись библиотеками и стандартными механизмами расширений.
* **Тестирование контрактов, ориентированных на потребителя (Consumer-Driven Contract Testing)**  
  Суть паттерна в том, что набор автоматизированных тестов для каждого сервиса (Provider Microservice)
  пишется разработчиками других сервисов (Consumer Microservice), вызывающих проверяемый сервис.
  Каждый такой набор тестов является контрактом, проверяющим, соответствует ли сервис провайдера ожиданиям потребителя.
  Сами тесты включают в себя запрос и ожидаемый ответ.
  Паттерн Consumer-Driven Contract Testing увеличивает автономность команд и
  позволяет своевременно обнаруживать изменения в сервисах, написанных другими командами.
  Но его применение может потребовать дополнительной работы по интеграции тестов,
  так как команды могут пользоваться различными инструментами тестирования.
* **Внешняя конфигурация (External Configuration)**  
  Хранить конфигурации локально — в файлах, развертываемых вместе с приложением,
  — считается очень плохой практикой, особенно при переходе на микросервисы.
  Это приводит к серьезным рискам безопасности и требует повторного развертывания
  при каждом изменении конфигурационных параметров.
  Поэтому в приложениях корпоративного уровня рекомендуется использовать шаблон External Configuration, 
  предлагающий хранить все конфигурации во внешнем хранилище.
  В качестве такого хранилища может выступать облачная служба хранения, база данных или другая система.


######


---

Info:
- https://mcs.mail.ru/blog/26-osnovnyh-patternov-mikroservisnoj-razrabotki

