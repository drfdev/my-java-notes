### Red-Black tree

_Красно-черное дерево_

Бинарное дерево поиска.  
Занимаемое место: `O(n)`,  
Поиск: `O(log(n))`,  
Вставка: лучшее `O(1)` - худшее `O(log(n))`  
Удаление: лучшее `O(1)` - худшее `O(log(n))`  

Каждый узел дерева содержит дополнительный байт - цвет (красный или черный)
Последние узлы дерева содержат пустые ссылки (NIL-value), и не содержат данных
В принципе, можно игнорировать существование NIL-узлов дерева

Условия налагаемые на красно-черное дерево:
- все условия бинарного дерева поиска
- все узлы содержат цвет (красный или черный)
- все NIL-узлы умеют черный цвет
- у красных узлов нет красных детей (черные узлы могут иметь черных детей)
- любой путь от узла к любому NIL-потомку содержит одинаковое количество черных узлов
Некоторые авторы добавляют требование `root-узел всегда черный`

Требования обеспечивают критическое свойство данного дерева:
`Путь от root-а до самого дальнего листа не больше чем в два раза длинее чем путь до самого ближнего листа`
(лист - это конец ветки дерева, а не просто узел)
Данное свойство обеспечивает поиск по дереву за логарифмическое время `O(log(n))`, дерево сбалансировано по высоте


Выполнение свойств дерева обеспечивает вставку и удаление узлов за логарифмическое время (не превышающее) `O(log(n))`


###### Операция вставки

Новые элементы вставляются в NIL-узлы (листья), вставленный узел окрашивается в красный цвет.
Далее проверятся все свойства дерева:
- если дерево было пустым и корень имеет красный цвет - тогда корень перекрашивается в черный
- новый узел получает черный листья (NIL-узлы)
- если красный узел имеет красный дочерний узел - происходит перебалансировка дерева
- пути в дереве содержат разное количество черных узлов - происходит перебалансировка дерева


###### Перебалансировка дерева

Условные обозначения вершин:

* X — добавленный элемент
* P — папа элемента Х
* G — дедушка элемента Х, папа элемента Р
* U — дядя элемента Х, брат элемента Р, второй сын элемента G.


**Случай 1: красный дядя**
```text
      G(b)                            G(r)
     /    \                          /    \
   P(r)   U(r)   перекрашивание    P(b)   U(b)
   /                               /
 X(r)                            X(r)
```

Если и отец, и дядя красного цвета, то мы можем «спустить» чёрный цвет с уровня деда на уровень отца
и перекрасить узлы, как показано на рисунке. В этом случае «чёрная высота» останется прежней,
однако возможно нарушение правила `Оба потомка каждого красного узла — чёрные` для элемента G,
поэтому необходимо рекурсивно вызвать дальнейшую балансировку для этого узла.

**Случай 2: чёрный дядя — папа и дед в разных сторонах**
```text
      G(b)                         G(b)
     /    \                       /    \
   P(r)   U(b)   поворот        X(r)    U(b)
   /  \                         /
 nil   X(r)                   P(r)
```

```text
      G(b)                        G(b)
     /    \                      /    \
   U(b)   P(r)    поворот      U(b)    X(r)
          /  \                            \
        X(r)  nil                         P(r)
```

Эту структуру необходимо привести к третьему случаю,
когда папа и дед идут в одну сторону. Для этого нужно выполнить малый поворот от сына Х
к его отцу и вызвать 3 случай для элемента Р.

**Случай 3: чёрный дядя — папа и дед в одной стороне**
```text
      G(b)                     P(b)
     /    \                   /    \
   P(r)   U(b)   большой    X(r)   G(r)
   /             поворот              \
 X(r)                                 U(b)
```

```text
      G(b)                      P(b)
     /    \                    /    \
   U(r)   P(b)    большой    G(r)   X(r)
             \    поворот    /       
             X(r)          U(b)      
```

В этом случае мы уже можем совершить большой поворот от отца через деда к чёрному дяде
и перекрасить Р в чёрный, а G в красный.
В результате этого поворота правило `Оба потомка каждого красного узла — чёрные` будет выполнено.

Убедимся, что правило `Путь вниз от любого узла до любого листа-потомка содержит одинаковое число чёрных узлов` тоже выполняется.
Предположим, что до большого поворота чёрная высота элемента G была N+2.
Тогда высота «подвешенных» элементов будет следующей:

```text
A = N+1,
B = N+1,
C = N+1,
D = N,
E = N.
```


###### Примеры перебалансировки

Теперь рассмотрим процесс формирования красно-чёрного дерева при последовательной вставке элементов 1, 2, 3, 4, 5 и 6.

**Вставка 1**:
```text
      1(r)     -->     1(b)
```
Так как элемент 1 является корнем — мы его просто перекрашиваем для выполнения 1 правила.

**Вставка 2**:
```text
      1(b)
         \
         2(r)
```
После добавления элемента 2 все правила выполняются.

**Вставка 3**:
```text
      1(b)                
         \                   2(r)                 2(b)
         2(r)     -->       /    \     -->       /    \
           \              1(b)  3(r)           1(r)  3(r)
           3(r)           
```

При добавлении элемента 3 у нас нарушилось правило `Оба потомка каждого красного узла — чёрные`.
Так как у нас дядя чёрный, а дед и отец с одной стороны, то мы применяем третий случай — делаем поворот и перекрашиваем.

**Вставка 4**:
```text
   2(b)                    2(r)                    2(b)
  /    \                  /    \                  /    \
1(r)  3(r)      -->     1(b)   3(b)     -->     1(b)   3(b)
         \                       \                       \
         4(r)                    4(r)                    4(r)
```

При добавлении элемента 4 у нас опять нарушается правило `Оба потомка каждого красного узла — чёрные`.
На этот раз дядя у нас красный, поэтому применим первый случай с перекрашиванием — чёрная высота дерева увеличится на 1.
Обратите внимание. что алгоритм балансировки запускается ещё дополнительно для деда — элемента 2,
который, как корень, просто перекрашивается в чёрный цвет.

**Вставка 5**:
```text
    2(b)
   /    \                   2(b)                     2(b)
1(b)   3(b)                /   \                    /   \
         \       -->     1(b)   4(r)      -->     1(b)   4(b)
         4(r)                  /   \                    /   \
           \                 3(b)   5(r)              3(r)   5(r)
           5(r)
```

При вставке элемента 5 мы снова применяем 3 случай — делаем большой поворот и перекрашиваем вершины.
Обратите внимание, что чёрная высота не изменилась.

**Вставка 6**:
```text
   2(b)                      2(b)
  /   \                     /   \
1(b)   4(b)               1(b)   4(r)
      /   \       -->           /   \
    3(r)   5(r)               3(b)   5(b)
             \                         \
             6(r)                      6(r)
```

При добавлении элемента 6 мы снова нарушили правило `Оба потомка каждого красного узла — чёрные`.
Так как наш дядя красный, то применяем первый случай с перекрашиванием, чёрная высота не изменилась.
Вызов балансировки для 4 элемента ничего не изменило в дереве, так как этот элемент не нарушает правил.


---

Ссылки:
* https://en.wikipedia.org/wiki/Red%E2%80%93black_tree
* https://habr.com/ru/articles/330644/
* https://habr.com/ru/companies/otus/articles/472040/