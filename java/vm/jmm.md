### Java Memory Model

##### Java Heap

Делится на 2 части:
- new generation
    - eden
    - survivor
- old generation (tenured space)

Размер хипа задается параметрами: -Xmx (максимальный размер), -Xms (минимальный, начальный размер)

Как происходит работа:  
Новый объект создается в Eden. Как только Eden заполняется, происходит его чистка.
Объекты которые еще нужны (is reachable) копируются в survivor, остальные данные удаляются из Eden (minor GC)

Survivor состоит из двух блоков: S0 и S1  
JVM выбирает одно из пространств S0 или S1, и копирует в него данные, второе пространство остается пустым.
При записи объекта в survivor его возраст увеличивается на 1, если в survivor месте нет, то объект может быть
сразу записан в tenured space

Как только survivor заполняется, происходит его очистка. Все недоступные объекты удаляются, а доступные копируются
во второй раздел survivor (из S0 -> S1), а текущий раздел очищается. И возраст выживших объектов увеличивается.

Как только объект копируется несколько раз (достигает максимального возраста), он копируется в tenured space
Максимальный возраст задается параметром -XX:MaxTenuringThreshold, и по умолчанию имеет значение 15


##### Java Permgen (Permanent Generation)

Используется JVM для хранения метаданных об объектах (и другие необходимые данные)  
Задается параметрами: -XX:PermSize (начальный размер) и -XX:MaxPermSize (максимальный размер)  
Говорят, что лучше генерировать PG сразу максимального размера, чтобы во время работы у JVM не было необходимости ее
перестраивать (и тратить на это ресурсы)

Существует только в старых версиях java



##### Java Metaspace

Внешняя память, аналог Permgen  
По умолчанию может расти бесконечно, так же можно задать параметром -XX:MaxMetaspaceSize



##### Java Code Cache

Специальная область памяти для JIT компилятора  
Часто вызываемый код будет скомпилирован в нативный код и сохранен в этот кэш для быстрого повторного вызова

