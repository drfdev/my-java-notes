### java.lang.Object

Высший класс в любой иерархии, все классы являются его наследниками.
Все объекты (включая массивы) реализуют его методы

Список методов:
* getClass():
  Возвращает класс объекта (в рантайме)
  Метод native, final


* hashCode():
  Метод нужный для вычисления хешкода, для различных хеш-структур (таких как HashMap)
  Контракт:
  1) возвращает число соответствующее текущему состоянию объекта.
     Должно быть консистентно, для одного и того же объекта должно возвращаться одно и тоже значение, до момента его изменения
     Расчет хешкода должен быть одинаков для одинаковых объектов, запущенных в той же программе в другой раз
  2) когда два объекта одинаковые через метод equals(), шехкоды должны быть одинаковыми
  3) не требуется чтобы для разных объектов по методу equals() расчитывались уникальные значения хешкода
     Но стоит попытаться генерировать уникальные значения для разных объектов, чтобы улучшить производительность
  
  Значние по умолчанию: System.identityHashCode(), чья реализация зависит от используемой JVM.
  Но использовать реализацию по умолчанию не рекомендуется.


* equals(Object):
  Указывает на то что текущий объект одинаковый с пришедшим параметром
  Реализация по умолчанию через `this == object`
  Соглашение по методу:
  1) Рефлексивность: 
     для ненулевого X, выражение X.equals(X) всегда true
  2) Симметричность:
     Для ненулевых X и Y, если X.equals(Y) равно true, то и Y.equals(X) должно быть true
  3) Транзитивность:
     Для ненулевых X, Y и Z, если X.equals(Y) и Y.equals(Z) должно выполняться X.equals(Z)
  4) Консистентность:
     Для ненулевого X, выражение X.equals(null) всегда false
  
  Чтобы не нарушить контракт с hashCode() при переопределении hashCode() стоит переопределить и equals()


* clone():
  Метод создания копии объекта. Под копией понимается выполнение следующих условий:
  1) x.clone() != x
  2) x.clone().getClass() == x.getClass()
  3) x.clone().equals(x)
  
  Если у класса есть родитель, требуется чтобы клон вызывал super.clone(), перед тем как объект будет возвращен
  Для класса Object вызов clone() может выбросить CloneNotSupportedException, если подкласс не реализует интерфейс Cloneable (которые Object по умолчанию не реализует)
  Массивы реализуют Cloneable, но полная копия возможна только с массивами примитивных типов. Для массивов объектов делается "теневая копия".
  При этом в массиве остаются ссылки на исходные объекты, а не их "глубокие копии"


* toString():
  Представление объекта в виде строки
  По умолчанию: `getClass().getName() + "@" + Integer.toHexString(hashCode())`


* wait() / wait(long) / wait(long, int):
  Заставляет текущий поток ждать, пока он не будет пробужден, по не будет вызван notify() или прерван (interrupted)
  или пока не пройдет некоторое время (таймаут указанный в параметрах)
  Текущий поток должен владеть блокировкой монитора текущего объекта.

  Этот метод заставляет текущий поток (далее T) ставит себя в состояние ожидания для этого объекта, 
  а затем отказываться от всех требований синхронизации к этому объекту.
  Снимаются блокировки только этого объекта; любые другие объекты, на которых может быть синхронизирован текущий поток,
  остаются заблокированными, пока поток ждет

  Затем поток T отключается и бездействует до тех пор, пока не произойдет одно из следующих событий:

  - Другой поток вызывает метод notify() для этого объекта, и поток T оказывается выбранным (произвольно) в качестве потока, который будет разбужен.
  - Другой поток вызывает метод notifyAll() для этого объекта.
  - Другой поток прерывает поток T.
  - Указанное количество реального времени (таймаут) истекло (более или менее).
    Количество реального времени в наносекундах определяется выражением 1000000 * timeoutMillis + nanos.
    Если timeoutMillis и nanos равны нулю, то реальное время не принимается во внимание, и поток ожидает пробуждения по одной из других причин.
  - Поток T пробуждается ложным образом. (См. ниже.)

  Затем поток T удаляется из списка (состояния) ожидания для этого объекта и снова включается для планирования потоков.
  Он начинает конкурировать с другими потоками за право синхронизировать объект как обычно (обычным образом);
  как только он восстанавливает контроль над объектом, все его требования синхронизации к объекту восстанавливаются до status quo ante (статус кво),
  то есть до состояния на момент вызова метода wait().
  Затем поток T возвращается из вызова метода wait(). Таким образом, при возврате из метода wait() состояние синхронизации объекта 
  и потока T точно такое же, как при вызове метода ожидания.
 
  Поток может проснуться без уведомления, прерывания или тайм-аута, так называемое ложное пробуждение.
  Хотя на практике это случается редко, приложения должны защищаться от этого, проверяя условие, которое должно было вызвать пробуждение потока,
  и продолжая ждать, если условие не выполняется. См. Пример ниже.

  Для получения дополнительной информации по этой теме см. Раздел 14.2 «Очереди условий» в книге Brian Goetz и других «Java Concurrency in Practice» (Addison-Wesley, 2006) 
  или в пункте 69 в книге Joshua Bloch «Effective Java, Second Edition», (Addison-Wesley, 2008).
 
  Если текущий поток прерывается каким-либо потоком до или во время ожидания, генерируется InterruptedException.
  Прерванный статус текущего потока очищается, когда возникает это исключение.
  Это исключение не генерируется, пока состояние блокировки этого объекта не будет восстановлено, как описано выше.


* notify():
  Пробуждает единственный поток, ожидающий на мониторе этого объекта.
  Если какие-либо потоки ждут на этом объекте, один из них выбирается для пробуждения.
  Выбор произвольный и происходит в зависимости от реализации. Поток ожидает на мониторе объекта, вызывая один из методов wait().

  Пробужденный поток не сможет продолжить работу, пока текущий поток не снимет блокировку с этого объекта.
  Пробужденный поток будет соревноваться обычным образом с любыми другими потоками, которые могут активно конкурировать за синхронизацию на этом объекте;
  Пробужденный поток не имеет привилегий или ограничений в том, чтобы следующим занять блокировку на объекте.
  
  Этот метод должен вызываться только потоком, который является владельцем монитора этого объекта.
  Поток становится владельцем монитора объекта одним из трех способов:
  - Выполняя синхронизированный метод экземпляра этого объекта.
  - Выполняя тело синхронизированного оператора, который синхронизируется с объектом.
  - Для объектов типа Class, выполняя синхронизированный статический метод этого класса.
  
  Только один поток одновременно может владеть монитором объекта.


* notifyAll():
  Пробуждает все потоки, ожидающие на мониторе этого объекта. Поток ожидает на мониторе объекта, вызывая один из методов wait().

  Пробужденный поток не сможет продолжить работу, пока текущий поток не снимет блокировку с этого объекта.
  Пробужденный поток будет соревноваться обычным образом с любыми другими потоками, которые могут активно конкурировать за синхронизацию на этом объекте;
  Пробужденный поток не имеет привилегий или ограничений в том, чтобы следующим занять блокировку на объекте.

  Этот метод должен вызываться только потоком, который является владельцем монитора этого объекта.
  См. описание выше


* finalize():
  Вызывается сборщиком мусора для объекта, когда сборщик мусора определяет, что на этот объект больше нет ссылок.
  Подкласс должен переопределить метод finalize для очистки

  Основной контракт в том, что метод вызывается когда JVM понимает что к данному потоку больше нет ссылок из живых потоков, исключая
  все что уже было финализировано ранее.
  Метод финализации может сделать объект снова активным (включая доступ для других тредов), для целей финализации
  Обычная цель finalize - выполнить действия по очистке до того, как объект будет безвозвратно удален.
  Например, финализация может использовать input/output соединения, может выполнять неявные I/O транзакции чтобы разорвать эти соединения
  до того как объект будет безвозвратно удален

  В классе Object метод не делает ничего, его нужно переопределять

  Java не определяет каким потоком будет вызван данный метод. Однако вызвавший поток не будет держать какие-либо блокировки на этом объекте.
  Если метод бросает исключение - метод будет сразу же завершен, а ошибка проигнорирована.

  После завершения метода finalize, с объектом ничего не происходит, до тех пор пока Java VM не определит что объект больше не доступен
  ни из какого живого треда, включая возможные действия другими объектами или классами, которые уже были финализированы.
  И только после этого объект может быть удален

  Метод не вызывается больше одного раза для любого объекта
  Любое исключение вызывает остановку финализации, но игнорируется

  Deprecated с 9 версии Java
  Механизм финализации по своей сути проблематичен.
  Завершение может привести к проблемам с производительностью, зависаниям и дедлокам.
  Ошибки в финализаторах могут привести к утечке ресурсов; нет возможности отменить финализацию, если она больше не нужна;
  и между вызовами финализации методов различных объектов не указывается порядок.
  Кроме того, нет никаких гарантий относительно сроков завершения.
  Метод finalize может быть вызван для финализируемого объекта только после неопределенной задержки, если вообще вызван.
  Классы, экземпляры которых содержат ресурсы вне кучи (non-heap resources), должны предоставлять метод, позволяющий явным образом освобождать эти ресурсы,
  а также при необходимости должны реализовывать AutoCloseable.
  Cleaner и PhantomReference предоставляют более гибкие и эффективные способы высвобождения ресурсов, когда объект становится недоступным. 
