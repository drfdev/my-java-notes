### java.lang.Object

Высший класс в любой иерархии, все классы являются его наследниками.
Все объекты (включая массивы) реализуют его методы

Список методов:
* getClass():
  Возвращает класс объекта (в рантайме)
  Метод native, final


* hashCode():
  Метод нужный для вычисления хешкода, для различных хеш-структур (таких как HashMap)
  Контракт:
  1) возвращает число соответствующее текущему состоянию объекта.
     Должно быть консистентно, для одного и того же объекта должно возвращаться одно и тоже значение, до момента его изменения
     Расчет хешкода должен быть одинаков для одинаковых объектов, запущенных в той же программе в другой раз
  2) когда два объекта одинаковые через метод equals(), шехкоды должны быть одинаковыми
  3) не требуется чтобы для разных объектов по методу equals() расчитывались уникальные значения хешкода
     Но стоит попытаться генерировать уникальные значения для разных объектов, чтобы улучшить производительность
  
  Значние по умолчанию: System.identityHashCode(), чья реализация зависит от используемой JVM.
  Но использовать реализацию по умолчанию не рекомендуется.


* equals(Object):
  Указывает на то что текущий объект одинаковый с пришедшим параметром
  Реализация по умолчанию через `this == object`
  Соглашение по методу:
  1) Рефлексивность: 
     для ненулевого X, выражение X.equals(X) всегда true
  2) Симметричность:
     Для ненулевых X и Y, если X.equals(Y) равно true, то и Y.equals(X) должно быть true
  3) Транзитивность:
     Для ненулевых X, Y и Z, если X.equals(Y) и Y.equals(Z) должно выполняться X.equals(Z)
  4) Консистентность:
     Для ненулевого X, выражение X.equals(null) всегда false
  
  Чтобы не нарушить контракт с hashCode() при переопределении hashCode() стоит переопределить и equals()


* clone():
  Метод создания копии объекта. Под копией понимается выполнение следующих условий:
  1) x.clone() != x
  2) x.clone().getClass() == x.getClass()
  3) x.clone().equals(x)
  
  Если у класса есть родитель, требуется чтобы клон вызывал super.clone(), перед тем как объект будет возвращен
  Для класса Object вызов clone() может выбросить CloneNotSupportedException, если подкласс не реализует интерфейс Cloneable (которые Object по умолчанию не реализует)
  Массивы реализуют Cloneable, но полная копия возможна только с массивами примитивных типов. Для массивов объектов делается "теневая копия".
  При этом в массиве остаются ссылки на исходные объекты, а не их "глубокие копии"


* toString():
  Представление объекта в виде строки
  По умолчанию: `getClass().getName() + "@" + Integer.toHexString(hashCode())`


* wait() / wait(long) / wait(long, int):
  Заставляет текущий поток ждать, пока он не будет пробужден, по не будет вызван notify() или прерван (interrupted)
  или пока не пройдет некоторое время (таймаут указанный в параметрах)
  Текущий поток должен владеть блокировкой монитора текущего объекта.

  Этот метод заставляет текущий поток (далее T) ставит себя в состояние ожидания для этого объекта, 
  а затем отказываться от всех требований синхронизации к этому объекту.
  Снимаются блокировки только этого объекта; любые другие объекты, на которых может быть синхронизирован текущий поток,
  остаются заблокированными, пока поток ждет

  Затем поток T отключается и бездействует до тех пор, пока не произойдет одно из следующих событий:

  - Другой поток вызывает метод notify() для этого объекта, и поток T оказывается выбранным (произвольно) в качестве потока, который будет разбужен.
  - Другой поток вызывает метод notifyAll() для этого объекта.
  - Другой поток прерывает поток T.
  - Указанное количество реального времени (таймаут) истекло (более или менее).
    Количество реального времени в наносекундах определяется выражением 1000000 * timeoutMillis + nanos.
    Если timeoutMillis и nanos равны нулю, то реальное время не принимается во внимание, и поток ожидает пробуждения по одной из других причин.
  - Поток T пробуждается ложным образом. (См. ниже.)

  Затем поток T удаляется из списка (состояния) ожидания для этого объекта и снова включается для планирования потоков.
  Он начинает конкурировать с другими потоками за право синхронизировать объект как обычно (обычным образом);
  как только он восстанавливает контроль над объектом, все его требования синхронизации к объекту восстанавливаются до status quo ante (статус кво),
  то есть до состояния на момент вызова метода wait().
  Затем поток T возвращается из вызова метода wait(). Таким образом, при возврате из метода wait() состояние синхронизации объекта 
  и потока T точно такое же, как при вызове метода ожидания.
 
  Поток может проснуться без уведомления, прерывания или тайм-аута, так называемое ложное пробуждение.
  Хотя на практике это случается редко, приложения должны защищаться от этого, проверяя условие, которое должно было вызвать пробуждение потока,
  и продолжая ждать, если условие не выполняется. См. Пример ниже.

  Для получения дополнительной информации по этой теме см. Раздел 14.2 «Очереди условий» в книге Brian Goetz и других «Java Concurrency in Practice» (Addison-Wesley, 2006) 
  или в пункте 69 в книге Joshua Bloch «Effective Java, Second Edition», (Addison-Wesley, 2008).
 
  Если текущий поток прерывается каким-либо потоком до или во время ожидания, генерируется InterruptedException.
  Прерванный статус текущего потока очищается, когда возникает это исключение.
  Это исключение не генерируется, пока состояние блокировки этого объекта не будет восстановлено, как описано выше.


* notify() / notifyAll():


* finalize():


