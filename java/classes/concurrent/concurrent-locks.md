### java.util.concurrent


##### Locks:  


---

**interface Lock**

Интерфейс локов.
Реализации данного интерфейса предоставляют более обширные блокировки, через ключевое слово synchronized.
Предоставляется гибкая структура, так же поддержка дополнительных условий `Condition`

Локи - это инструмент контроля доступа к общим ресурсам, в многопоточных программах. Коротко: предоставляет
эксклюзивный доступ к общему ресурсу для одного потока.

Использование:
```java
Lock l = ...;
l.lock();
try {
    // access the resource protected by this lock
} finally {
    l.unlock();
}
```

Локи реализауюдополнительный функционал (в отличии от synchronized): есть не блокирующая попытка проверить блокировку
метод tryLock(), попытка взять блокировку может быть прервана, например, по таймауту, метод tryLock(long, TimeUnit)

Методы:
* void lock():
  получение блокировки
  если блокировка недоступна, поток блокируется (disabled) и бездействует пока блокировка не будет доступной
* void lockInterruptibly():
  получение блокировки, пока текущий тред не будет прерван (interrupted, метод Thread.interrupt())
  если блокировка недоступна, поток блокируется (disabled) и бездействует пока не случится одна из двух вещей:
  1) блокировка будет взята текущим тредом
  2) другой поток прервет (interrupt) текущий поток
  метод кидает InterruptedException
* boolean tryLock():
  берет блокировку если она свободна на момент вызова
  если блокировка доступна, она будет взята и метод вернет true, если блокировка недоступна метод вернет false
  пример использования метода:
  ```java
  Lock lock = ...;
  if (lock.tryLock()) {
    try {
        // manipulate protected state
    } finally {
        lock.unlock();
    }
  } else {
    // perform alternative actions
  }
  ```
* boolean tryLock(long, TimeUnit):
  пытается взять блокировку, за заданное время и текущий поток не прерван (interrupted)
  если блокировка доступна, она будет взята немедленно и метод вернет true
  если блокировка недоступна, то поток становится недоступным (disabled) и ждет пока не случится одно из событий:
  1) блокировка будет взята
  2) какой-то другой поток не прервет (interrupt) текущий поток
  3) время ожидания истечет
  если блокировка будет взята - вернется значение true, если время истечет - вернется значение false
  так же метод может выкинуть InterruptedException
* void unlock():
  отпускает блокировку
* Condition newCondition():
  возвращает новое условие (Condition) связанное с данной блокировкой
  может выкинуть UnsupportedOperationException, если данный метод не поддерживается

---

**interface ReadWriteLock**

Предоставляет две связанные блокировки (на запись и на чтение)

Методы:
* Lock readLock():
  блокировка для операций чтения
* Lock writeLock():
  блокировка для операций записи

---

**interface Condition**

Условия  
Нужны для того чтобы приостановить выполнение одного потока (wait) пока другой поток не выполнит какое-то условие

Пример работы:
```java
class BoundedBuffer<E> {
    final Lock lock = new ReentrantLock();
    final Condition notFull  = lock.newCondition(); 
    final Condition notEmpty = lock.newCondition(); 
 
    final Object[] items = new Object[100];
    int putptr, takeptr, count;
 
    public void put(E x) throws InterruptedException {
      lock.lock();
      try {
        while (count == items.length)
          notFull.await();
        items[putptr] = x;
        if (++putptr == items.length) putptr = 0;
        ++count;
        notEmpty.signal();
      } finally {
        lock.unlock();
      }
    }
 
    public E take() throws InterruptedException {
      lock.lock();
      try {
        while (count == 0)
          notEmpty.await();
        E x = (E) items[takeptr];
        if (++takeptr == items.length) takeptr = 0;
        --count;
        notFull.signal();
        return x;
      } finally {
        lock.unlock();
      }
    }
  }
```

В примере есть класс буффера с методами take() и put(T). Если вызываем take() на пустом буффере, то поток
блокируется пока в буффере не появится что-то. Если вызываем put(T) на заполненном буффере, то поток блокируется
пока не освободится место в буффере

Методы:
* void await():
  заставляет текущий поток ждать сигнала (методы signal или signalAll) или прерывания (interrupted)
* void awaitUninterruptibly():
  заставляет текущий поток ждать сигнала
* long awaitNanos(long):
  заставляет ждать пока не придет сигнал, или пока поток не будет прерван, или пока не истечет время
  возвращает время которое осталось ждать, значение меньше нуля означает время истекло
  пример кода:
  ```java
  boolean aMethod(long timeout, TimeUnit unit) throws InterruptedException {
    long nanosRemaining = unit.toNanos(timeout);
    lock.lock();
    try {
        while (!conditionBeingWaitedFor()) {
            if (nanosRemaining <= 0L)
                return false;
            nanosRemaining = theCondition.awaitNanos(nanosRemaining);
        }      
        // ...
        return true;
    } finally {
        lock.unlock();
     }
  }
  ```
  метод возвращает сколько времени осталось ждать, поэтому это значение может быть переиспользовано
  в то время как значение равное или меньшее нуля означает что время вышло
* boolean await(long, TimeUnit):
  заставляет текущий тред ждать пока придет сигнал, или прерывание, или пока не истечет время
  возвращает false если время ожидания истекло
* boolean awaitUntil(Date):
  заставляет текущий поток ждать пока не придет сигнал, или прерывания, или заданный deadline
  возвращает false, если deadline наступил
* void signal():
  будет один из ждущих потоков
* void signalAll():
  будет всех ждущих потоков

После получения сигнала потоки пытаются снова получить блокировку на методе await() [или аналогичном]
Реализация методов сигнала может требовать чтобы текущий поток брал блокировку (lock) связанную с этим условием

---

**ReentrantLock**

Блокировка, может быть взята только одним тредом (до момента unlock).
Особенность блокировки в том, что она может быть взята несколько раз одним и тем же потоком. Вызывать метод unlock()
отпуская блокировку нужно столько же раз сколько она была взята.
В конструкторе есть параметр fairness: если задан в значение true, то блокировка будет отдаваться потоку который
ждет дольше всех. При значении false - никаких гарантий нет.


---

**ReentrantReadWriteLock**

Реализации ReadWriteLock, использующая ту же семантику, что и ReentrantLock

Поддерживает следующие свойства:
* Acquisition order:
  Политика выбора блокировки (параметр конструктора):
  * Non-fair mode (default)
    не определен порядок взятия блокировок на чтение или запись
    должен иметь большую пропускную способность чем fair mode
  * Fair mode
    после освобождения блокировки выбирается самый долгий поток ожидающий блокировку на запись
    или если есть группа потоков ожидающая блокировки на чтение больше чем любой из потоков на запись
    вперед пропускается эта группа потоков
* Reentrancy
  блокировку на чтение или запись можно брать повторно для текущего потока
  писатель может так же повторно брать блокировку на чтение, но не наоборот
* Lock downgrading
  можно перейти (понизить привилегии) с блокировки на запись в блокировку на чтение, но нельзя наоборот
* Interruption of lock acquisition
  чтение и запись поддерживают прерывание потоков
* Condition support
  блокировка на запись поддерживает условия, блокировка на чтение кидает UnsupportedOperationException
* Instrumentation
  в классе есть методы просмотра состояния блокировки (держится или оспаривается)
  эти методы сделаны для системного мониторинга, а не для контроля синхронизации

---

**StampedLock**

Блокировка с 3 вариантами:
* Writing
  методы writeLock и unlockWrite
  дает эксклюзивный доступ, возвращает stamp, который нужно использовать для снятия блокировки
* Reading
  методы readLock и unlockRead
  дает не эксклюзивный доступ на чтение, так же возвращает stamp для снятия блокировки
* Optimistic Reading
  метод tryOptimisticRead
  возвращает не нулевой stamp, если блокировка не занята в режиме записи
  метод validate возвращает true если блокировка не занята в режиме записи
  это слабая версия read-lock, может быть сброшена в любой момент при появлении писателя
  данная опция нужна для быстрого чтения, чтобы увеличить производительность

Так же в классе есть методы позволяющие менять текущий тип блокировки, например, метод tryConvertToWriteLock
делает попытку повысить привилегии если выполнены условия

_Подробнее смотри комментарий в исходно коде_ 

