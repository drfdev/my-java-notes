### java.util.concurrent


##### Executors:  

Утилитный класс, содержит следующие методы:

* ExecutorService newFixedThreadPool(int nThreads):
  Создает пул потоков с фиксированным количеством потоков. Кроме этого у пула есть очередь (неограниченная).
  Какой-нибудь поток будет обрабатывать полученную задачу, если все потоки заняты, то задача ставится в очередь.
  Когда поток освобождается, он берет следующую задачу из очереди.
  Если поток умирает во время выполнения работы, то вместо него будет создан новый поток.
  Потоки в пуле существуют пока существует пул. Завершение пула можно выполнить методов shutdown.
* ExecutorService newWorkStealingPool(int parallelism):
  Создает ForkJoinPool, параметр parallelism - отвечает за максимальное количество потоков, которые будут
  использованы или доступны для параллельной обработки задачи. Реальное количество потоков может динамически
  меняться (расти или сокращаться). Данный пул не дает гарантий, что задачи будут обработаны в порядке их
  добавления в пул.
* ExecutorService newWorkStealingPool():
  Аналогичный предыдущему метод, где вместо parallelism используется количество доступных процессоров.
* ExecutorService newSingleThreadExecutor():
  Создает пул, с единственный рабочим потоком и неограниченной очередью. Если поток завершается по каким-либо причинам
  то новый поток будет создан (пул гарантирует, что поток будет существувовать пока существует пул). Так же пул гарантирует
  последовательное выполнение, не больше одной задачи может выполняться одновременно.
* ExecutorService newCachedThreadPool():
  Возвращает пул потоков, который создает новые потоки когда они необходимы (или использует предыдущие потоки, если они доступны).
  Данный пул должен улучшать работу программ, которые выполняют много асинхронных коротких по времени (short-lived) задач.
  При добавлении новой задачи: сначала будут переиспользованы потоки созданные ранее.
  Если такие потоки недоступны, будут созданы новые. Неиспользуемые больше 60 секунд потоки - завершаются и удаляются из кеша.
  Таким образом, если пул простаивает достаточно долго - он не будет потреблять никаких ресурсов.
* ScheduledExecutorService newSingleThreadScheduledExecutor():
  Возвращает экзекьютор с одним потоком, который может выполнять задачи после заданной задержки (отложено) или периодически.
  Гарантирует последовательное выполнение, гарантирует что не больше одной задачи будет выполняться одновременно.
  Если поток завершится до завершения экзекьютера, то будет создан новый поток.
* ScheduledExecutorService newScheduledThreadPool(int corePoolSize):
  Возвращает экзекьютор, который может выполнять задачи после заданной задержки (отложено) или периодически.
  Параметр corePoolSize задает количество потоков, которые будут в пуле, даже если они неактивны
* ExecutorService unconfigurableExecutorService(ExecutorService executor):
  Возвращает объект, который делегирует все методы переданному ExecutorService.
  Такой объект дает доступ только с стандартным методам ExecutorService, и не позволяет использовать дополнительные
  методы через приведение (cast) классов. Таким же образом, это позволяет "заморозить" конфигурацию сервиса.
* ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor):
  Делает тоже самое что и предыдущий метод, но для ScheduledExecutorService
* ThreadFactory defaultThreadFactory():
  Возвращает ThreadFactory по умолчанию, которая используется для создания новых потоков.

Дополнительные методы, не связанные с пулами потоков:
* Callable callable(Runnable task, T result):
  Возвращает Callable, который при вызове запускает данный task и возвращает данный result
* Callable callable(PrivilegedAction action):
  Возвращает Callable, который при запуске возвращает результат выполнения PrivilegedAction
* Callable callable(PrivilegedExceptionAction action):
  Возвращает Callable, который при запуске возвращает результат выполнения PrivilegedExceptionAction


---

**ThreadPoolExecutor**

~~TODO~~

---

**ForkJoinPool**

~~TODO~~

---

**ScheduledThreadPoolExecutor**

~~TODO~~

