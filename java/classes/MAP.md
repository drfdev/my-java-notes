### java.util.Map

Основные методы:
* int size():
  Возвращает количество пар ключ-значения
  Если в мапе больше чем `Integer.MAX_VALUE` значений, то возвращается `Integer.MAX_VALUE`
* boolean isEmpty():
  Возвращает true, если в мапе есть хотя бы одна пара ключ-значение
* boolean containsKey(Object):
  Возвращает true, если в мапе есть такой ключ
  Проверка происходит по equals
* boolean containsValue(Object):
  Возвращает true, если в папе хотя бы для одного ключа есть значение
  Проверка происходит по equals
* V get(Object):
  Возвращает значение по заданному ключу, или null если такого ключа нет
* V put(K key, V value):
  Связывает ключ key со значением value, если ключ уже существует, то просто обновляется связанное значение
  Возвращается предыдущее значение
* V remove(Object key):
  Удаляется пара ключ-значение по ключу.
  Возвращает значение связанное с этим ключом
* void putAll(Map<? extends K, ? extends V>):
  Копирует данные из мапы в текущую мапу
* void clear():
  Удаляет все значения из мапы (если мапа пустая - то ничего не происходит)

Views:
* Set<K> keySet():
  Возвращает `Set` содержащий все ключи данной мапы
* Collection<V> values():
  Возвращает коллекцию всех значений
* Set<Map.Entry<K, V>> entrySet():
  Возвращает `Set` всех пар ключ-значения

Методы по умолчанию:
* V getOrDefault(Object key, V defaultValue):
  Возвращает значения по ключу, или defaultValue если ключа в мапе нет
* void forEach(BiConsumer<? super K, ? super V>):
  Выполняет заданную функцию для всех entry в данной мапе
* void replaceAll(BiFunction<? super K, ? super V, ? extends V>):
  Обновляет значения для каждого ключа на результат заданной функции
* V putIfAbsent(K key, V value):
  Добавляет пару ключ-значение если данного ключа еще нет, возвращает предыдущее значение
  Реализация по умолчанию:
  ```java
  V v = get(key);
  if (v == null) {
    v = put(key, value);
  }
  return v;
  ```
* boolean remove(Object key, Object value):
  Удаляет entry если оно соответвует паре параметров ключ-значение 
* boolean replace(K key, V oldValue, V newValue):
  Обновляет значение по ключу, если оно равно oldValue на новое значение newValue
* V replace(K key, V value):
  Обновляет значение в мапе, если по данному ключу есть хотя бы одно значение
  Возвращает предыдущее значение (или null если значения нет в мапе)
* V computeIfAbsent(K key, Function<? super K, ? extends V>):
  Если переданный ключ ни с чем не ассоциирован, то в мапу добавляется значение вычисленное через переданную функцию
  Возвращается текущее или вычисленное значение
  Если функция вернет null, то значение не будет добавлено в мапу
* V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V>):
  Если ключ задан в мапе и связан с не нулевым значением, тогда происходит попытка вычислить новое значение
  по ключу и текущему значению
  Если функция вернет null, то значение будет удалено из мапы
  Возвращает новое (вычисленное) значение
* V compute(K key, BiFunction<? super K, ? super V, ? extends V>):
  Пытается вычислить значение по заданному ключу, для текущего значения или null-значения если в мапе нет такого ключа
  Пример использования: `map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))`
  Если генерирующая функция возвращает null, то пара ключ-значение будет удалено из мапы
  Возвращает новое (вычисленное) значение
* V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V>):
  Если по ключу в мапе ничего нет, или возвращается null - тогда пара ключ-значение будет добавлен
  Если пара ключ-значение уже существует - тогда значение будет обновлено результатом выполнения функции
  Если функция возвращает null - пара ключ-значение удаляется
  Возвращает новое значение


---

**java.util.HashMap**

Принимает null-ключи и null-значения  
Эквивалент `Hashtable`, но не синхронизованный  
Не гарантирует порядок значений, не гарантирует что порядок будет сохранен при изменении мапы  

Производительность для put и get операций работает за константное время `O(1)`
Задается двумя параметрами `initial capacity` и `load factor`,
capacity: это количество бакетов, load factor: определяет когда мапе нужно расти (увеличиваться в 2 раза)
По умолчанию capacity = 16, load factor = 0.75

Устройство мапы такое:
Внутри есть корзины, в которые складываются значения. Если в корзине слишком много значений, то список преобразуется
в дерево. Внутри корзин находится объект Node, в котором лежит ключ-значение. Выбор корзины происходит по хешу.
Для ключа обязательна хорошая реализация `equals()` и `hashCode()`

---

**java.util.TreeMap**

Реализация `NavigableMap` на основе красно-черного дерева.  
Внутри мапы ключи отсортированы в натуральном порядке или заданным компоратором.
Реализация гарантирует `log(n)` время для операций `containsKey` / `get` / `put` / `remove`

Реализация не синхронизована  
Не принимает null-ключи  

Красно-черно дерево: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree  
Так же разбор должен быть в папке algorithms


---

**java.util.EnumMap**

Специализированная мапа, используемая в качестве ключа значения Enum
Размер такой карты задан изначально, сама мапа представляет собой массив
Такое представление экстремально компактно и эффективно

Null-ключ запрещен  
Коллекция не синхронизована


---

**java.util.LinkedHashMap**

---

**java.util.Hashtable**

---

**java.util.concurrent.ConcurrentMap** (interface)

---

**java.util.SortedMap** (interface)

---

**java.util.concurrent.ConcurrentHashMap**

---

**java.util.concurrent.ConcurrentSkipListMap**

---

**java.util.SynchronizedMap** (in Collections)

---

**java.util.EmptyMap** (in Collections)

---

**java.util.SingletonMap** (in Collections)

---

**java.util.IdentityHashMap**

---

**java.util.CheckedMap** (in Collections)

---

**java.util.WeakHashMap**

---

**java.util.Map**

`static` методы самого интерфейса:

* of()
  Возвращает пустую неизменяемую мапу
* of(...)
  Возвращает неизменяемую мапу, с заданными значениями
  Реализации мапы оптимизированы для разного количества элементов
* ofEntries(Entry<K, V>...)
  Возвращает неизменяемую мапу, оптимизированную относительно размера varags
* copyOf(Map<K, V>)
  Возвращает копию мапы
  Если мапа неизменяемая - возвращается сама мапа
  Копия неизменяемая

