### java.util.Map

Основные методы:
* int size():
  Возвращает количество пар ключ-значения
  Если в мапе больше чем `Integer.MAX_VALUE` значений, то возвращается `Integer.MAX_VALUE`
* boolean isEmpty():
  Возвращает true, если в мапе есть хотя бы одна пара ключ-значение
* boolean containsKey(Object):
  Возвращает true, если в мапе есть такой ключ
  Проверка происходит по equals
* boolean containsValue(Object):
  Возвращает true, если в папе хотя бы для одного ключа есть значение
  Проверка происходит по equals
* V get(Object):
  Возвращает значение по заданному ключу, или null если такого ключа нет
* V put(K key, V value):
  Связывает ключ key со значением value, если ключ уже существует, то просто обновляется связанное значение
  Возвращается предыдущее значение
* V remove(Object key):
  Удаляется пара ключ-значение по ключу.
  Возвращает значение связанное с этим ключом
* void putAll(Map<? extends K, ? extends V>):
  Копирует данные из мапы в текущую мапу
* void clear():
  Удаляет все значения из мапы (если мапа пустая - то ничего не происходит)

Views:
* Set<K> keySet():
  Возвращает `Set` содержащий все ключи данной мапы
* Collection<V> values():
  Возвращает коллекцию всех значений
* Set<Map.Entry<K, V>> entrySet():
  Возвращает `Set` всех пар ключ-значения

Методы по умолчанию:
* V getOrDefault(Object key, V defaultValue):
  Возвращает значения по ключу, или defaultValue если ключа в мапе нет
* void forEach(BiConsumer<? super K, ? super V>):
  Выполняет заданную функцию для всех entry в данной мапе
* void replaceAll(BiFunction<? super K, ? super V, ? extends V>):
  Обновляет значения для каждого ключа на результат заданной функции
* V putIfAbsent(K key, V value):
  Добавляет пару ключ-значение если данного ключа еще нет, возвращает предыдущее значение
  Реализация по умолчанию:
  ```java
  V v = get(key);
  if (v == null) {
    v = put(key, value);
  }
  return v;
  ```
* boolean remove(Object key, Object value):
  Удаляет entry если оно соответвует паре параметров ключ-значение 
* boolean replace(K key, V oldValue, V newValue):
  Обновляет значение по ключу, если оно равно oldValue на новое значение newValue
* V replace(K key, V value):
  Обновляет значение в мапе, если по данному ключу есть хотя бы одно значение
  Возвращает предыдущее значение (или null если значения нет в мапе)
* V computeIfAbsent(K key, Function<? super K, ? extends V>):
  Если переданный ключ ни с чем не ассоциирован, то в мапу добавляется значение вычисленное через переданную функцию
  Возвращается текущее или вычисленное значение
  Если функция вернет null, то значение не будет добавлено в мапу
* V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V>):
  Если ключ задан в мапе и связан с не нулевым значением, тогда происходит попытка вычислить новое значение
  по ключу и текущему значению
  Если функция вернет null, то значение будет удалено из мапы
  Возвращает новое (вычисленное) значение
* V compute(K key, BiFunction<? super K, ? super V, ? extends V>):
  Пытается вычислить значение по заданному ключу, для текущего значения или null-значения если в мапе нет такого ключа
  Пример использования: `map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))`
  Если генерирующая функция возвращает null, то пара ключ-значение будет удалено из мапы
  Возвращает новое (вычисленное) значение
* V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V>):
  Если по ключу в мапе ничего нет, или возвращается null - тогда пара ключ-значение будет добавлен
  Если пара ключ-значение уже существует - тогда значение будет обновлено результатом выполнения функции
  Если функция возвращает null - пара ключ-значение удаляется
  Возвращает новое значение


---

**java.util.HashMap**

Принимает null-ключи и null-значения  
Эквивалент `Hashtable`, но не синхронизованный  
Не гарантирует порядок значений, не гарантирует что порядок будет сохранен при изменении мапы  

Производительность для put и get операций работает за константное время `O(1)`
Задается двумя параметрами `initial capacity` и `load factor`,
capacity: это количество бакетов, load factor: определяет когда мапе нужно расти (увеличиваться в 2 раза)
По умолчанию capacity = 16, load factor = 0.75

Устройство мапы такое:
Внутри есть корзины, в которые складываются значения. Если в корзине слишком много значений, то список преобразуется
в дерево. Внутри корзин находится объект Node, в котором лежит ключ-значение. Выбор корзины происходит по хешу.
Для ключа обязательна хорошая реализация `equals()` и `hashCode()`

---

**java.util.TreeMap**

Реализация `NavigableMap` на основе красно-черного дерева.  
Внутри мапы ключи отсортированы в натуральном порядке или заданным компоратором.
Реализация гарантирует `log(n)` время для операций `containsKey` / `get` / `put` / `remove`

Реализация не синхронизована  
Не принимает null-ключи  

Красно-черно дерево: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree  
Так же разбор должен быть в папке algorithms ( `tree/red-black-tree.md` )


---

**java.util.EnumMap**

Специализированная мапа, используемая в качестве ключа значения Enum
Размер такой карты задан изначально, сама мапа представляет собой массив
Такое представление экстремально компактно и эффективно

Null-ключ запрещен  
Коллекция не синхронизована


---

**java.util.LinkedHashMap**

Реализация мапы через хеш таблицу и связанный список, с предсказуемым порядком итерации.  
Унаследовано от `HashMap`, разница в реализации в том, что есть поддержка
двусвязанный список который проходит через все элементы (entity).

Порядок итерации элементов в мапе в порядке вставки.
Порядок не меняется, при повторной вставке элемента.

Реализация спасает клиента от хаотического порядка элементов в `HashMap` или `Hashtable`,
без увеличения стоимости связанной с `TreeMap`  
Можно скопировать существующую мапу, с сохранением порядка:
```java
void foo(Map<String, Integer> m) {
    Map<String, Integer> copy = new LinkedHashMap<>(m);
    // ...
}
```

Есть специальный конструктор:  
`public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)`  
В который передается параметр accessOrder - метод порядка в связанном списке  
true - в порядке доступа;  
false - в порядке вставки;  

Коллекция не синхронизована


---

**java.util.Hashtable**

Реализация хеш таблицы, не принимает null-значения в качестве ключей и значений  
Реализация принимает два параметра _initial capacity_ и _load factor_  
initial capacity - количество корзин (бакетов) для хештаблицы  
load factor - определяет заполненность мапы, после которого размер мапы автоматически увеличивается

Значение load factor по умолчанию 0.75  
Значение initial capacity по умолчанию 11  

Мапы полностью сихронизована (через synchronized).
Итератор не гарантирует сихронизованный доступ ко всем элементам.
Если нужна потоко-безопасная highly-concurrent реализация, то стоит использовать `java.util.concurrent.ConcurrentHashMap`


---

**java.util.concurrent.ConcurrentMap** (interface)

Макркерный интерфейс, обозначающий мапы с гарантированной потокобезопасностью и атомарностью  
Переопределяет некоторые дефолтные методы из `Map`


---

**java.util.SortedMap** (interface)

Интерфейс означает что данная мапа имеет сортировку по ключам  
Сортировка происходит или в натуральном порядке, или через данный компаратор

Дополнительные методы:
* Comparator<? super K> comparator():
  Возвращает компаратор этой мапы или null, если сортировка в натуральном порядке
* SortedMap<K,V> subMap(K fromKey, K toKey):
  Возвращает часть мапы (view), которая задана в промежутке ключей fromKey и toKey
* SortedMap<K,V> headMap(K toKey):
  Возвращает часть мапы (view), где ключи строго меньше чем заданный ключ
* SortedMap<K,V> tailMap(K fromKey):
  Возвращает часть мапы (view), где ключи больше или равны чем заданный ключ
* K firstKey():
  Возвращает первый (наименьший) ключ
* K lastKey():
  Возвращает последний (наибольший) ключ


---

**java.util.NavigableMap** (interface)

~~TODO~~

---

**java.util.concurrent.ConcurrentHashMap**

~~TODO~~

---

**java.util.concurrent.ConcurrentSkipListMap**

~~TODO~~

---

**java.util.SynchronizedMap** (in Collections)

Декоратор для мапы, у которого все методы синхронизованы (по некоему mutex)  
Переменная mutex может быть передан в один из конструкторов (конструктор закрытый, поэтому его просто так не вызвать)


---

**java.util.EmptyMap** (in Collections)

Пустая мапа. Есть одна переменная, которая возвращается через метод `Collections.emptyMap()`


---

**java.util.SingletonMap** (in Collections)

Декоратор для одной пары ключ-значение


---

**java.util.IdentityHashMap**

~~TODO~~

---

**java.util.CheckedMap** (in Collections)

Мапы с проверкой типов объектов.  
Если пытаться вставить в мапу ключ и значение с неверными типами будет брошен ClassCastException

Есть два подкласса `CheckedNavigableMap` и `CheckedSortedMap` (связанный с соответственными интерфейсами)


---

**java.util.WeakHashMap**

~~TODO~~

---

**java.util.Map**

`static` методы самого интерфейса:

* of()
  Возвращает пустую неизменяемую мапу
* of(...)
  Возвращает неизменяемую мапу, с заданными значениями
  Реализации мапы оптимизированы для разного количества элементов
* ofEntries(Entry<K, V>...)
  Возвращает неизменяемую мапу, оптимизированную относительно размера varags
* copyOf(Map<K, V>)
  Возвращает копию мапы
  Если мапа неизменяемая - возвращается сама мапа
  Копия неизменяемая


---

**java.util.SequencedMap**

~~TODO~~

